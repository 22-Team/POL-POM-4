#!/bin/bash

# Copyright (C) 2007-2011 PlayOnLinux Team
# Copyright (C) 2007-2011 Pâris Quentin

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA. 


generer_icone ()
{
	ICONE=$1
	NOMICONE=$2
	NOMCOURT="$NOMICONE"
	PLACE=$3
	EXECUTER=$4
	
	mkdir -p $PLACE
	cd $PLACE
	echo "[Desktop Entry]" > "$NOMCOURT.desktop"
	echo "Encoding=UTF-8" >> "$NOMCOURT.desktop"
	echo "Name=$NOMICONE" >> "$NOMCOURT.desktop"
	echo "GenericName=Game" >> "$NOMCOURT.desktop"
	echo "Comment=PlayOnLinux" >> "$NOMCOURT.desktop"
	echo "Type=Application" >> "$NOMCOURT.desktop"
	echo "Exec=$EXECUTER" >> "$NOMCOURT.desktop"
	echo "Icon=$ICONE" >> "$NOMCOURT.desktop"
	echo "Categories=PlayOnLinux;" >> "$NOMCOURT.desktop"
	echo "Name[fr_FR]=$NOMICONE" >> "$NOMCOURT.desktop"
	chmod +x "$NOMCOURT.desktop"
}

creer_lanceur_base ()
{
	# 1 = Wineprefix
	# 2 = Repertoire
	# 3 = Binaire
	# 4 = Icone (png ou xpm)
	# 5 = Nom de l'icône
	# 6 = Ignoré (question de compatibilité avec les versions < 2.0)
	# 7 = Eventuel argument

	Binaire="$3"
	SpecialArg="$7"

	if [ "$5" = "" ]
	then
		NOMICONE_="$1"
	else
		NOMICONE_="$5"
	fi
	
	mkdir -p "$REPERTOIRE/icones/32"
	mkdir -p "$REPERTOIRE/icones/full_size"
	
	ICON_WEB_NAME="$4"
	ICON_OK=0

	
	# Création de l'icone.
	
	# Cas 1 : le nom de l'icone est donné.
	if [ -n "$ICON_WEB_NAME" ]; then
		if [ ! "$OFFLINE" = "1" ]; then # On peut le télécharger...
			wget -q "$SITE/icones/$ICON_WEB_NAME" -O "$REPERTOIRE/icones/full_size/$NOMICONE_" # On prend l'icone full size
		fi
		
		if [ -f "$REPERTOIRE/icones/full_size/$NOMICONE_" ]; then
			convert -resize 32 "$REPERTOIRE/icones/full_size/$NOMICONE_" "$REPERTOIRE/icones/32/$NOMICONE_" # On fabrique l'icone 32*32
			ICON_OK=1
		fi
	elif [ "$ICON_OK" -ne 1 ]; then # Pas d'incone sur le web => Création à partir de l'exe...
		echo "No iternet icon..."
		
		mkdir -p "$REPERTOIRE/tmp/win32Icon"
		wrestool -x "$REPERTOIRE/wineprefix/$1/drive_c/$2/$Binaire" -o "$REPERTOIRE/tmp/win32Icon" -t14
		
		cd "$REPERTOIRE/tmp/win32Icon"
		win32IconName=$(ls -S *.ico | head -n 1)
		if [ -f "$win32IconName" ]; then # L'ico est créé
			convert ICO:"$win32IconName" -resize 32 PNG:"$REPERTOIRE/icones/32/$NOMICONE_" # On fabrique l'icone 32*32
		fi # Si non : icone play on linux.

		rm -r "$REPERTOIRE/tmp/win32Icon"
		
		# On ne crée pas d'icone "full_size", parce que les résolutions des icones windows ne sont pas suffisantes tout le temps.
		# Pour verifier la taille des icones, il faudrait utiliser "identify", mais ce programme n'est pas toujours fournis.
	fi
	
	echo "#!/bin/bash" > "$REPERTOIRE/shortcuts/$NOMICONE_"
	echo "[ \"\$PLAYONLINUX\" = \"\" ] && exit 0" >> "$REPERTOIRE/shortcuts/$NOMICONE_"
	echo "source \"\$PLAYONLINUX/lib/sources\"" >> "$REPERTOIRE/shortcuts/$NOMICONE_"
	echo "export WINEPREFIX=\"$REPERTOIRE/wineprefix/$1\"" >> "$REPERTOIRE/shortcuts/$NOMICONE_"
	echo "export WINEDEBUG=\"-all\"" >> "$REPERTOIRE/shortcuts/$NOMICONE_"
	echo "cd \"$REPERTOIRE/wineprefix/$1/drive_c/$2\"" >> "$REPERTOIRE/shortcuts/$NOMICONE_"
	echo "POL_Wine \"$Binaire\" $SpecialArg \$@" >> "$REPERTOIRE/shortcuts/$NOMICONE_"
	chmod +x "$REPERTOIRE/shortcuts/$NOMICONE_"
}

POL_Shortcut_InsertBeforeWine ()
{
	# 1 = Application
	# 2 = Commandes to insert

	Application="$1"
	CommandesToInsert="$2"

	mv "$REPERTOIRE/shortcuts/${Application}" "$REPERTOIRE/shortcuts/${Application}".bak
	perl -ne "s/^(wine.*)/${CommandesToInsert}\n\1/;print" "$REPERTOIRE/shortcuts/${Application}".bak > "$REPERTOIRE/shortcuts/${Application}"
	rm "$REPERTOIRE/shortcuts/${Application}".bak
}

detect_wineprefix()
{
	file="$REPERTOIRE/shortcuts/$1"
	if [ -e "$file" ]
	then	
		fichier=$(cat "$file" | grep WINEPREFIX)
		fichier=${fichier:18}
		fichier=${fichier//"\""/""}
		fichier=${fichier//"//"/"/"}
	fi
	echo $fichier
}
detect_wineversion()
{
	wineprefixback="$WINEPREFIX"
	export WINEPREFIX="$(detect_wineprefix "$1")"
	POL_Config_PrefixRead "VERSION"
	export WINEPREFIX="$wineprefixback"
}
detect_appdir()
{
	file="$REPERTOIRE/shortcuts/$1"
	if [ -e "$file" ]
	then	
	fichier=`cat "$file" | grep "cd \""`
	fichier=${fichier:4:${#fichier}-5}
	fi
	echo $fichier
}
detect_appexec()
{
	file="$REPERTOIRE/shortcuts/$1"
	if [ -e "$file" ]
	then	
	fichier=`cat "$file" | grep "wine " | cut -d'"' -f2`
	fi
	echo $fichier
}
clean_wineprefix()
{ 
	# Ca c'est fait exprès ! On touche pas
	[ "$1" = "$REPERTOIRE/.PlayOnLinux/wineprefix/" ] && exit
	[ "$1" = "$REPERTOIRE/Library/PlayOnMac/" ] && exit

	# Préfixe (chemin complet)
	cd "$REPERTOIRE/shortcuts/"
	# Ça aussi, j'ai pas utilisé $REPERTOIRE volontairment (question de sécu, si $REPERTOIRE est vide ou mal défini, ça peut faire mal)
	[ "$POL_OS" = "Linux" ] && TEST=${1//".PlayOnLinux/wineprefix/"/""}
	[ "$POL_OS" = "Mac" ] && TEST=${1//"Library/PlayOnMac/wineprefix/"/""}
	
	[ "$TEST" = "" ] && exit
	if [ "$TEST" = "$1" ]
	then
		POL_Debug_Error "Le répértoire n'est pas dans PlayOnLinux/PlayOnMac"
	else
		used=0
		for file in *
		do
			fichier="${file}"
			prefix=$(detect_wineprefix "$fichier")
			if [ "$prefix" = "$1" ]
				then
				used=1
			fi
		done
		if [ "$used" = 1 ] 
			then
			echo "$1 est encore utilisé."
		else
			prefix=$1
			prefix=$(basename "$1")
			POL_SetupWindow_question "$(eval_gettext "Do you want to delete the virtual drive:")\n\n$prefix" "Wine"
			reponse=$APP_ANSWER
			POL_SetupWindow_wait_next_signal "$(eval_gettext 'Uninstalling...')" "$(eval_gettext '$APPLICATION_TITLE Uninstaller')" 
			if [ "$reponse" = "TRUE" ]
			then
				rm -rf $1
			fi
			POL_SetupWindow_detect_exit
		fi
	fi
}
POL_SetupWindow_get_local_icon()
{
	convert "$HOME/.local/share/icons/$2" -geometry 32X32 "$REPERTOIRE/icones/32/$1"
	convert "$HOME/.local/share/icons/$2" "$REPERTOIRE/icones/full_size/$1"
}
POL_GPG_install_key()
{
	#create the gnupg directory
	mkdir -p "$GNUPGHOME"
	#import the public key
	if [ "$POL_OS" = "Linux" ]
	then
		gpg --import "$PLAYONLINUX/etc/playonlinux.gpg" > /dev/null 2> /dev/null
	else
		NEW_DL_PATH="$PLAYONLINUX/../unix/tools/lib/gettext/:$DYLD_LIBRARY_PATH"
		env DYLD_LIBRARY_PATH="$NEW_DL_PATH" gpg --import "$PLAYONLINUX/etc/playonlinux.gpg" > /dev/null 2> /dev/null
	fi
}
POL_GPG_auth_script()
{
POL_GPG_install_key
FILENAME="$1"
GPG=`awk '/^-----BEGIN PGP SIGNATURE-----/ {print NR ; exit 0; }' $FILENAME`

tail -n +${GPG} "$FILENAME" > "$REPERTOIRE/tmp/script.asc" 2> /dev/null
head -n $(( GPG - 1 )) "$FILENAME"  | grep -v "cat << \"-----END PGP SIGNATURE-----\" > /dev/null" > "$REPERTOIRE/tmp/script" 2> /dev/null

if [ "$POL_OS" = "Linux" ]
then
	gpg --verify "$REPERTOIRE/tmp/script.asc" > /dev/null 2> /dev/null
else
	NEW_DL_PATH="$PLAYONLINUX/../unix/tools/lib/gettext/:$DYLD_LIBRARY_PATH"
	env DYLD_LIBRARY_PATH="$NEW_DL_PATH" gpg --verify "$REPERTOIRE/tmp/script.asc" > /dev/null 2> /dev/null
fi

[ "$?" = "0" ] && echo "TRUE" || echo "FALSE"
}
POL_Browser ()
{
	POL_Open "$@"
}

get_existing_POL_SetupWindow_shortcut_creator()
{
	cd "$REPERTOIRE/shortcuts"
	for file in *
	do
		if [ ! "$(cat "$file" | grep $WINEPREFIX)" = "" ]
		then
			cat "$file" | grep "wine " | awk '{print $2}' | tr -d "\""
		fi
	done
}
POL_SetupWindow_shortcut_creator()
{
	# No argument, this function uses WINEPREFIX
	[ "$WINEPREFIX" = "" ] && POL_Debug_Fatal "POL_SetupWindow_shortcut_creator : wineprefix not set"
	existing="$(get_existing_POL_SetupWindow_shortcut_creator)"
	
	cd "$WINEPREFIX/drive_c"
	CODENAME="$(POL_MD5 "$WINEPREFIX")"
	mkdir -p "$POL_USER_ROOT/tmp/cache/icons/$CODENAME"
	cp "$PLAYONLINUX/resources/images/icones/browse.png" "$POL_USER_ROOT/tmp/cache/icons/$CODENAME"
	cp "$PLAYONLINUX/resources/images/icones/finish.png" "$POL_USER_ROOT/tmp/cache/icons/$CODENAME"	
	POL_SetupWindow_wait_next_signal "$(eval_gettext "Scanning the virtual drive ...")" "$TITLE"
	contents="$(find . -iname *.exe | grep -v "./windows" | grep -v iexplore.exe | process_POL_SetupWindow_shortcut_creator)"
	LNG_FINISH="$(eval_gettext "I don't want to make another shortcut")"
	LNG_BROWSE="$(eval_gettext "Browse")"
	[ "$contents" = "" ] || CONTENTS2="~$contents"
	POL_SetupWindow_icon_menu "$(eval_gettext "Please choose a file for $APPLICATION_TITLE to make a shortcut")" "$TITLE"  "$LNG_FINISH~$LNG_BROWSE$CONTENTS2" "~" "$POL_USER_ROOT/tmp/cache/icons/$CODENAME" "finish.png~browse.png$CONTENTS2"
	
	EXE_FILE=""
	if [ "$APP_ANSWER" = "$LNG_BROWSE" ]
	then
		cd $WINEPREFIX/drive_c || POL_Debug_Fatal "Prefix : $WINEPREFIX does not exist"
		POL_SetupWindow_browse "$(eval_gettext "Please choose a file for $APPLICATION_TITLE to make a shortcut")" "$TITLE"
		EXE_FILE="$(basename "$APP_ANSWER")"
	elif [ ! "$APP_ANSWER" = "$LNG_FINISH" ]
	then
		EXE_FILE="$APP_ANSWER"
	fi
	if [ ! "$EXE_FILE" = "" ]
	then
		POL_SetupWindow_textbox "$(eval_gettext "Please choose a shortcut name for $EXE_FILE")" "$TITLE"
		TITRE="$APP_ANSWER"
		POL_Shortcut "$EXE_FILE" "$TITRE"
		echo "POL_Shortcut \"$EXE_FILE\" \"$TITRE\"" >> "$POL_USER_ROOT/tmp/shortcuts"
		if [ ! "$1" = "" ]
		then
			Set_WineVersion_Assign "$1" "$TITRE"
		fi
		echo "Set_WineVersion_Assign \"$1\" \"$TITRE\"" >> "$POL_USER_ROOT/tmp/shortcuts"
		POL_SetupWindow_shortcut_creator
	fi
}

process_POL_SetupWindow_shortcut_creator ()
{
	read line
	first=true
	while [ ! "$line" = "" ]
	do
		if [ "$(echo $existing | grep $(basename "$line"))" = "" ] 
		then
			#echo "On tente d'extraire $WINEPREFIX/drive_c/$line"
			POL_ExtractIcon "$WINEPREFIX/drive_c/$line" "$POL_USER_ROOT/tmp/cache/icons/$CODENAME/$(basename "$line")" 2> /dev/null > /dev/null
			# Si il parle il fiche tout en l'air
			[ "$first" = "true" ] && first=false || printf "~"
			printf "$(basename "$line")"
		fi
		read line
	done
}
POL_Config_Write ()
{
	cat "$POL_USER_ROOT/playonlinux.cfg" 2> /dev/null | grep -v "^$1" > "$POL_USER_ROOT/tmp/newcfg"
	echo "$1=$2" >> "$POL_USER_ROOT/tmp/newcfg"
	mv "$POL_USER_ROOT/tmp/newcfg" "$POL_USER_ROOT/playonlinux.cfg"
}
POL_Config_Delete ()
{
	cat "$POL_USER_ROOT/playonlinux.cfg" 2> /dev/null | grep -v "^$1" > "$POL_USER_ROOT/tmp/newcfg"
	mv "$POL_USER_ROOT/tmp/newcfg" "$POL_USER_ROOT/playonlinux.cfg"
}
POL_Config_Read ()
{
	cat "$POL_USER_ROOT/playonlinux.cfg" 2> /dev/null | grep "^$1" | cut -d\= -f2
}

POL_Config_PrefixWrite ()
{
	cat "$WINEPREFIX/playonlinux.cfg" 2> /dev/null | grep -v "^$1" > "$POL_USER_ROOT/tmp/newcfg"
	echo "$1=$2" >> "$POL_USER_ROOT/tmp/newcfg"
	mv "$POL_USER_ROOT/tmp/newcfg" "$WINEPREFIX/playonlinux.cfg"
}
POL_Config_PrefixDelete ()
{
	cat "$WINEPREFIX/playonlinux.cfg" 2> /dev/null | grep -v "^$1" > "$POL_USER_ROOT/tmp/newcfg"
	mv "$POL_USER_ROOT/tmp/newcfg" "$WINEPREFIX/playonlinux.cfg"
}
POL_Config_PrefixRead ()
{
	cat "$WINEPREFIX/playonlinux.cfg" 2> /dev/null | grep "^$1" | cut -d\= -f2
}

POL_System_TmpCreate()
{
	# 1 : TmpName
	[ "$1" = "" ] && POL_Debug_Fatal "TmpName not defined !"
	mkdir -p "$POL_USER_ROOT/tmp/$1"
	export POL_System_TmpDir="$POL_USER_ROOT/tmp/$1"
	export POL_System_TmpName="$1"
}
POL_System_TmpDelete()
{
	# Sans arguments
	[ ! "$POL_System_TmpName" = "" ] && rm -rf "$POL_USER_ROOT/tmp/$POL_System_TmpName" || POL_Debug_Warning "POL_System_TmpName is not defined !"
}
POL_System_SetArch()
{
	# Auto, x86, amd64
	if [ "$1" == "auto" ]
	then
		[ "$MACHTYPE" == "x86_64-pc-linux-gnu" ] && export POL_ARCH="amd64" || export POL_ARCH="x86"
	fi
	if [ "$1" == "x86" ]
	then
		export POL_ARCH="x86"
	fi
	if [ "$1" == "amd64" ]
	then
		[ "$MACHTYPE" == "x86_64-pc-linux-gnu" ] && export POL_ARCH="amd64" || POL_Debug_Fatal "amd64 is not supported by your system"
	fi	
}
POL_Shortcut_GetPrefix()
{
	[ "$1" = "" ] && POL_Debug_Error "No shortcut specified"
	fichier="$REPERTOIRE/shortcuts/$1"
	#fichier=${fichier//"\""/""}
	#fichier=${fichier//"//"/"/"}
	if [ -e "$fichier" ]
	then
		fichier="$(cat "$fichier" | grep WINEPREFIX | tail -n 1 | sed s/'\/\//\/'/)"
		fichier="${fichier/"$POL_USER_ROOT"/""}"
		fichier="$(printf "$fichier" | cut -d "/" -f2)"
	fi
	printf "$fichier" | tr -d \"
}